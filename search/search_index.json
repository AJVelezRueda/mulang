{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mulang A universal, multi-language, multi-paradigm code analyzer Mulang is three different - but thighly related - things: an intermediate language, known as the Mulang AST ; a command line tool for analysing the Mulang AST and some popular languages by transforming to it. This tool is distributed as both a linux-amd64 binary and a JavaScript package. See downloads section . a Haskell composable combinators library for analysing the Mulang AST; Contributors Franco Bulgarelli @flbulgarelli Mumuki Julian Berbel Alt @julian-berbel @ Mumuki Federico Lochbaum @FedeLochbaum @ UNQ Lucas Traverso @ludat @ 10Pines","title":"Home"},{"location":"#mulang","text":"A universal, multi-language, multi-paradigm code analyzer Mulang is three different - but thighly related - things: an intermediate language, known as the Mulang AST ; a command line tool for analysing the Mulang AST and some popular languages by transforming to it. This tool is distributed as both a linux-amd64 binary and a JavaScript package. See downloads section . a Haskell composable combinators library for analysing the Mulang AST;","title":"Mulang"},{"location":"#contributors","text":"Franco Bulgarelli @flbulgarelli Mumuki Julian Berbel Alt @julian-berbel @ Mumuki Federico Lochbaum @FedeLochbaum @ UNQ Lucas Traverso @ludat @ 10Pines","title":"Contributors"},{"location":"astspec/","text":"Mulang AST spec In this section, we will get into the technical details of the Mulang AST. It is built around 5 core elements: Expressions Patterns Types Equations Generators All the AST elements fall within any of these 5 categories. Expressions Expressions are the most important element kind, since contain most of the information of a Mulang program and are always the root element of it. In fact, this implementation does not contain an AST or Program datatype - it is instead types as Expression . Expression in Mulang model what you will normally spec in a language as a expression, that is something that holds a value and a type. For example, 4 + 5 and [2, 3].toString() are typical expresion. However, Mulang extends this concept to most kind of elements in a program, regadless they are have an actual value in the original language. For example, class declarations and while statements are modeled as expression, although in many languages they aren't. As a rule of thumb if something is or can be represented as an statement, declararion or expression, the it is modeled as Expression in Mulang AST. Record A Record represents a record, data or struct declaration, as found in most procedural and functional languages, like the C-like struct declaration Syntax (Record Identifier) C Example struct Point { int x; int y; } (Record Point ) Caveats Currently, the Record expression does not hold information about the record contents. TypeAlias , TypeSignature and TypeCast Mulang AST support for type analysis is quite limited, and it is mostly focused on expressions and declarations analysis. However, for sake of completeness and in order to provide some limited type-information in Mulang AST, TypeAlias , TypeSignature and TypeCast expressions are provided. See types section for more details. EntryPoint Entry point with its name and body. It typically correspond to C-like main procedures, or program declarations. Syntax (EntryPoint Identifier Expression) Java Example public static main(String[] args) {} (EntryPoint main MuNil) Function Functional / Imperative programming function declaration. It is is composed by an identifier and one or more equations Syntax (Function Identifier [Equation]) Example Procedure Imperative programming procedure declaration. It is composed by an identifier and one or more equations Syntax (Procedure Identifier [Equation]) Method Object oriented programming method declaration. It is composed by an identifier and one or more equations Syntax (Method Identifier [Equation]) Ruby Example class Bird def sing! puts singing in the dead of night end end (Class Bird Nothing (Method sing! (Equation [] (UnguardedBody (Print (MuString singing in the dead of night )))))) Java Example public class Bird { public void sing() { System.out.println( singing in the dead of night ); } } (Class Bird Nothing (Method sing (Equation [] (UnguardedBody (Print (MuString singing in the dead of night )))))) EqualMethod and HashMethod Declaration of custom equivalance and hash code operations. EqualMethod typically corresponds to equals or == method declarations, while HashMethod , typically corresponds to hash or hashCode - like methods. Syntax (EqualMethod [Equation]) (HashMethod [Equation]) Ruby Example def ==(other) end def hash end (Sequence [ (EqualMethod (Equation [VariablePatten other ] (UnguardedBody MuNil))), (HashMethod (Equation [] (UnguardedBody MuNil)))] Variable Generic variable declaration, composed by an identifier and an initializer Syntax (Variable Identifier Expression) Example Assignment Syntax (Assignment Identifier Expression) Example Attribute Object oriented programming attribute declaration, composed by an identifier and an initializer Syntax (Attribute Identifier Expression) Example Object Object oriented programming global, named object declaration, like Scala's object , composed by a name and a body. Syntax (Object Identifier Expression) Example Class Object oriented programming global, class declaration, composed by a name, an optional superclass and a body Syntax (Class Identifier (Maybe Identifier) Expression) Ruby Example class Bird Animal end (Class Bird (Just Animal ) MuNil) Java Examples public class Bird extends Animal {} (Class Bird (Just Animal ) MuNil) Enumeration Imperative named enumeration of values Syntax (Enumeration Identifier [Identifier]) Java Example public enum Fuzzy { YES, NO, MAYBE } (Enumeration Fuzzy [ YES , NO , MAYBE ]) Interface Object oriented programming global interface or contract declaration, composed by a name, superinterfaces and a body. Syntax (Interface Identifier [Identifier] Expression) Java Example public interface Foo extends Bar, Baz { void foo(); } (Interface Foo [ Bar , Baz ] (TypeSignature foo [] void )) Rule Logic programming declaration of rule fact, composed by the rule name, rule arguments, and rule body Syntax (Rule Identifier [Pattern] [Expression]) Example baz(bar) :- foo(bar) (Rule baz [(LiteralPattern bar )] [(Exist foo [(LiteralPattern bar )])]) Fact Logic programming declaration of a fact , composed by the fact name and fact arguments Syntax (Fact Identifier [Pattern]) Example foo(bar). (Fact foo [(LiteralPattern bar )]) Exist Logic programming existential cuantification / consult Syntax (Exist Identifier [Pattern]) Example Not Logic programming negation Syntax (Not Expression) Example Findall Logic programming findall Syntax (Findall Expression Expression Expression) Example Forall Logic programming universal cuantification Syntax (Forall Expression Expression) Example Reference Generic variable Syntax (Reference Identifier) Example Application Generic, non-curried application of a function or procedure, composed by the applied element itself, and the application arguments Syntax (Application Expression [Expression]) Example Send Object oriented programming message send, composed by the reciever, selector and arguments Syntax (Send Expression Expression [Expression]) Ruby Example 1 + 5 (Send (MuNumber 1) (Reference + ) [MuNumber 5]) New Object oriented instantiation, composed by the class reference and instantiation arguments Syntax (New Identifier [Expression]) Example Implement Object oriented instantiation, interface implementation Syntax (Implement Identifier) Example Include Object oriented instantiation, mixin inclusion Syntax (Include Identifier) Example If Syntax (If Expression Expression Expression) Lambda Syntax (Lambda [Pattern] Expression) Return Syntax (Return Expression) While Imperative programming conditional repetition control structure, composed by a condition and a body Syntax (While Expression Expression) Example Repeat Imperative programming fixed repetition control structure, composed by a repetition count expression, and a body Syntax (Repeat Expression Expression) Example Match Syntax (Match Expression [Equation]) Switch Syntax (Switch Expression [(Expression, Expression)]) Try Generic try expression, composed by a body, a list of exception-handling patterns and statments, and a finally expression Syntax (Try Expression [(Pattern, Expression)] Expression) Example Raise Generic raise expression, like a throw or raise statament, composed by the raised expression Syntax (Raise Expression) Example Print Generic print expression Syntax (Print Expression) Ruby Example puts Hello World (Print (MuString Hello World )) For For s generalices the concept of comprehensions an indexed repetition. With a For you can build: ForComprehension , when the for expression is a yield. Scala's for comprehensions, Erlang's and Haskell's list comprehensions, and Haskell's do-syntaxt map to it. ForEach , when the for expression is not a yield. Java's for: , or some scenarios of scala's for map to it. Syntax (For [Statment] Expression) Haskell Example m = [ f x | x - [1, 2, 3, 4] ] (Variable m (For [(Generator (VariablePattern x ) (MuList [(MuNumber 1), (MuNumber 2), (MuNumber 3), (MuNumber 4)]))] (Yield (Application (Reference f ) [(Reference x )])))) Java Example for (Integer i : ints) { System.out.println(i); } (For [(Generator (VariablePattern i ) (Reference ints ))] (Print (Reference i ))) ForLoop ForLoop represents the imperative programming c-style for loop: Syntax (ForLoop Expression Expression Expression Expression) Example for (var i = 0; i 10; i++) { console.log(i); } (ForLoop (Variable i (MuNumber 0.0)) (Application (Reference ) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Reference + ) [Reference i ,MuNumber 1.0])) (Send (Reference console ) (Reference log ) [Reference i ])) Sequence Generic sequence of statements Syntax (Sequence [Expression]) Example Other Syntax (Other) Equal and NotEqual Syntax (Equal) (NotEqual) Self Object oriented self-reference, like C-like this and Smalltalk-derived self Syntax (Self) None Used as a placeholder for empty bodies. Syntax (None) MuNil Generic nothing value literal - nil , null , () or unit . Syntax (MuNil) MuObject Object oriented unnamed object literal Syntax (MuObject Expression) JavaScript Example {} {foo: 1} {foo: 1, bar: 2} (MuObject MuNil) (MuObject (Attribute foo (MuNumber 1))) (MuObject (Sequence [ (Attribute foo (MuNumber 1)), (Attribute bar (MuNumber 2))])) MuNumber , MuBool , MuString , MuSymbol and MuChar Generic number, boolean, string, symbol (atoms) and char literals Syntax (MuNumber Double) (MuBool Bool) (MuString String) (MuSymbol String) (MuChar Char) Ruby Example 1 true hello :hello (Sequence [ (MuNumber 1), (MuBool True), (MuString hello ), (MuSymbol hello )]) MuTuple and MuList They represent tuples - generic non-uniform fixed-size collection of elements - and lists - generic uniform variable-size collection of elements. Lists typically map to arrays, lists or sequence-like structures. Syntax (MuTuple [Expression]) (MuList [Expression]) TestGroup , Test and Assert Generic test framework expressions used to represent unit tests. TestGroup represents a test grouping expression such as describe , context , etc Test represents a test expression such as it , etc Assert represents a test's assertion, such as assert.equals(...) , etc. It receives a boolean that represents whether the assertion is negated or not. Syntax (TestGroup Expression Expression) (Test Expression Expression) (Assert Bool Assertion) Javascript Example describe( succ , function() { it( succ of 3 is 4 , function() { assert.equals(succ(3), 4) }) }) TestGroup (MuString succ ) (Test (MuString succ of 3 is 4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0)))) Python Example class TestGroup(unittest.TestCase): def test_succ_of_3_is_4(): self.assertEqual(succ(3), 4) TestGroup (MuString TestGroup ) (Test (MuString test_succ_of_3_is_4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0)))) Assertion Assertions used within tests to dynamically ascertain the code's validity. An assertion can be one of: * Truth : Assert the truthfulness of a given expression. * Equality : Assert the equality of two given expressions. * Failure : Assert a given expression fails with a given error. Syntax (Truth Expression) (Equality Expression Expression) (Failure Expression Expression) Javascript Examples assert(true) Assert False (Truth (MuBool True)) assert.equals(3, 3) Assert False (Equality (MuNumber 3) (MuNumber 3)) assert.throws(function() { throw('error!') }, 'error!') Assert False (Failure (Lambda [] (Raise (MuString error! ))) (MuString error! )) Patterns Patterns are the second most important element of Mulang AST. They represent things that don't hold a value, but are instead used to match values, like patterns in imperative case or switch statements, functional pattern matching in match or case expressions, or exception matching in try-catch or begin-rescue -like statements in object oriented languages. VariablePattern Variable pattern represent a variable match. It corresponds to normal formal parameters in precedural languages, and to simple pattern matching against a free identifier. Syntax (VariablePattern String) JavaScript Example function foo(x, y) { } (Function foo [(Equation [(VariablePattern x ), (VariablePattern y )] (UnguardedBody MuNil))]) LiteralPattern Literal constant pattern Syntax (LiteralPattern String) Example InfixApplicationPattern Infix application pattern like 4:X Syntax (InfixApplicationPattern Pattern String Pattern) Caveats InfixApplicationPattern exposes the underying syntax and will be deprecated. ApplicationPattern prefix application pattern like f _ Syntax (ApplicationPattern String [Pattern]) Example TuplePattern tuple pattern like (3, _) Syntax (TuplePattern [Pattern]) Example ListPattern list pattern like [x, y, _] Syntax (ListPattern [Pattern]) Example FunctorPattern Prolog-like functor pattern, like f(X, 6) . Syntax (FunctorPattern Identifier [Pattern]) Example AsPattern Syntax (AsPattern Identifier Pattern) Example TypePattern A type pattern, like in exception handling constructs in most object-oriented languages Syntax (TypePattern Identifier) Example WildcardPattern Wildcard pattern, typically _ in functional an logic programming languages. Syntax (WildcardPattern) UnionPattern Syntax (UnionPattern [Pattern]) OtherPattern Other unrecognized pattern Syntax (OtherPattern) Types When processing statically-typed languages, all type-information - regardless we are typing a function, a variable or a class - is represented with the Type ADT, can be one of: SimpleType : composed by a type identifier and zero or type more constraints ParameterizedType : composed by input type parmaters, an output type, and type constratins ConstrainedType : composed by just type constraints. OtherType : an unrecognized type Type s can be introduced in the Mulang AST using the following elements: TypeAlias A TypeAlias represents a synonym for a type, like the type declaration in Haskell and Scala or C's typedef . It is a typical statically typed functional programming feature. Syntax (TypeAlias Identifier Identifier) Haskell Example type Point = (Int, Int) (TypeAlias Point (Int, Int) ) TypeSignature A TypeSignature represents an explicit type annotation for a computation, variable or module, as you can find in Java or Haskell. Syntax (TypeSignature Identifier Type) Haskell Examples Simple types: name :: String (TypeSignature name (SimpleType String [])) Simple types and constraints: f :: Num a = a ```` ```haskell (TypeSignature f (SimpleType a [ Num a ])) Parameterized types: elem :: (Eq a, Foldable t) = a - t a - Bool ```` ```haskell (TypeSignature elem (ParameterizedType [ a , t a ] Bool [ Eq a , Foldable t ])) Java Examples In Java, as in most typed C-like languages, type signature and variable declarations are bound. This means that, for example, a local variable declaration will produce both a TypeSignature and a Variable expression. Variable and attribute types: String name; (TypeSignature name (SimpleType String [])) Method types: String f() { return null; } (TypeSignature f (ParameterizedType [] String [])) Method types with type parameters: A A f() { return null; } (TypeSignature f (ParameterizedType [] A [ A ])) Method types with type parameters and constraints: A super B void f(A a) {} (TypeSignature f (ParameterizedType [ A ] void [ A super B ])) Class or interfaces types: class A B extends C, D extends C { } (TypeSignature A (ConstrainedType [ B extends C , D extends C ])) TypeCast A TypeCast represent explictly giving a type to an expression which may have static or dynamic impact on the program. It is aimed to represent type-casts in c-like languages and inline type signatures in functional languages. Syntax (TypeCast Expression Type) Haskell Examples Simple types: ... = 4 :: Num a = a (TypeCast (MuNumber 4) (SimpleType a [ Num a ])) Java Examples Variable and attribute types: (Integer) 4; (TypeCast (MuNumber 4) (SimpleType Integer [])) (Option Integer ) something; (TypeCast (Reference something ) (SimpleType Option Integer [])) Caveats The type constraints refer to type-constrained parametrizations that the cast introduces, and not any other kind of constraints the cast uses. That is whay the following Java code: (Num A ) something; produces: (TypeCast (Reference something ) (SimpleType Num A [])) instead of: (TypeCast (Reference something ) (SimpleType Num [ A ]))","title":"AST Spec"},{"location":"astspec/#mulang-ast-spec","text":"In this section, we will get into the technical details of the Mulang AST. It is built around 5 core elements: Expressions Patterns Types Equations Generators All the AST elements fall within any of these 5 categories.","title":"Mulang AST spec"},{"location":"astspec/#expressions","text":"Expressions are the most important element kind, since contain most of the information of a Mulang program and are always the root element of it. In fact, this implementation does not contain an AST or Program datatype - it is instead types as Expression . Expression in Mulang model what you will normally spec in a language as a expression, that is something that holds a value and a type. For example, 4 + 5 and [2, 3].toString() are typical expresion. However, Mulang extends this concept to most kind of elements in a program, regadless they are have an actual value in the original language. For example, class declarations and while statements are modeled as expression, although in many languages they aren't. As a rule of thumb if something is or can be represented as an statement, declararion or expression, the it is modeled as Expression in Mulang AST.","title":"Expressions"},{"location":"astspec/#record","text":"A Record represents a record, data or struct declaration, as found in most procedural and functional languages, like the C-like struct declaration","title":"Record"},{"location":"astspec/#syntax","text":"(Record Identifier)","title":"Syntax"},{"location":"astspec/#c-example","text":"struct Point { int x; int y; } (Record Point )","title":"C Example"},{"location":"astspec/#caveats","text":"Currently, the Record expression does not hold information about the record contents.","title":"Caveats"},{"location":"astspec/#typealias-typesignature-and-typecast","text":"Mulang AST support for type analysis is quite limited, and it is mostly focused on expressions and declarations analysis. However, for sake of completeness and in order to provide some limited type-information in Mulang AST, TypeAlias , TypeSignature and TypeCast expressions are provided. See types section for more details.","title":"TypeAlias, TypeSignature and TypeCast"},{"location":"astspec/#entrypoint","text":"Entry point with its name and body. It typically correspond to C-like main procedures, or program declarations.","title":"EntryPoint"},{"location":"astspec/#syntax_1","text":"(EntryPoint Identifier Expression)","title":"Syntax"},{"location":"astspec/#java-example","text":"public static main(String[] args) {} (EntryPoint main MuNil)","title":"Java Example"},{"location":"astspec/#function","text":"Functional / Imperative programming function declaration. It is is composed by an identifier and one or more equations","title":"Function"},{"location":"astspec/#syntax_2","text":"(Function Identifier [Equation])","title":"Syntax"},{"location":"astspec/#example","text":"","title":"Example"},{"location":"astspec/#procedure","text":"Imperative programming procedure declaration. It is composed by an identifier and one or more equations","title":"Procedure"},{"location":"astspec/#syntax_3","text":"(Procedure Identifier [Equation])","title":"Syntax"},{"location":"astspec/#method","text":"Object oriented programming method declaration. It is composed by an identifier and one or more equations","title":"Method"},{"location":"astspec/#syntax_4","text":"(Method Identifier [Equation])","title":"Syntax"},{"location":"astspec/#ruby-example","text":"class Bird def sing! puts singing in the dead of night end end (Class Bird Nothing (Method sing! (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))))","title":"Ruby Example"},{"location":"astspec/#java-example_1","text":"public class Bird { public void sing() { System.out.println( singing in the dead of night ); } } (Class Bird Nothing (Method sing (Equation [] (UnguardedBody (Print (MuString singing in the dead of night ))))))","title":"Java Example"},{"location":"astspec/#equalmethod-and-hashmethod","text":"Declaration of custom equivalance and hash code operations. EqualMethod typically corresponds to equals or == method declarations, while HashMethod , typically corresponds to hash or hashCode - like methods.","title":"EqualMethod and HashMethod"},{"location":"astspec/#syntax_5","text":"(EqualMethod [Equation]) (HashMethod [Equation])","title":"Syntax"},{"location":"astspec/#ruby-example_1","text":"def ==(other) end def hash end (Sequence [ (EqualMethod (Equation [VariablePatten other ] (UnguardedBody MuNil))), (HashMethod (Equation [] (UnguardedBody MuNil)))]","title":"Ruby Example"},{"location":"astspec/#variable","text":"Generic variable declaration, composed by an identifier and an initializer","title":"Variable"},{"location":"astspec/#syntax_6","text":"(Variable Identifier Expression)","title":"Syntax"},{"location":"astspec/#example_1","text":"","title":"Example"},{"location":"astspec/#assignment","text":"","title":"Assignment"},{"location":"astspec/#syntax_7","text":"(Assignment Identifier Expression)","title":"Syntax"},{"location":"astspec/#example_2","text":"","title":"Example"},{"location":"astspec/#attribute","text":"Object oriented programming attribute declaration, composed by an identifier and an initializer","title":"Attribute"},{"location":"astspec/#syntax_8","text":"(Attribute Identifier Expression)","title":"Syntax"},{"location":"astspec/#example_3","text":"","title":"Example"},{"location":"astspec/#object","text":"Object oriented programming global, named object declaration, like Scala's object , composed by a name and a body.","title":"Object"},{"location":"astspec/#syntax_9","text":"(Object Identifier Expression)","title":"Syntax"},{"location":"astspec/#example_4","text":"","title":"Example"},{"location":"astspec/#class","text":"Object oriented programming global, class declaration, composed by a name, an optional superclass and a body","title":"Class"},{"location":"astspec/#syntax_10","text":"(Class Identifier (Maybe Identifier) Expression)","title":"Syntax"},{"location":"astspec/#ruby-example_2","text":"class Bird Animal end (Class Bird (Just Animal ) MuNil)","title":"Ruby Example"},{"location":"astspec/#java-examples","text":"public class Bird extends Animal {} (Class Bird (Just Animal ) MuNil)","title":"Java Examples"},{"location":"astspec/#enumeration","text":"Imperative named enumeration of values","title":"Enumeration"},{"location":"astspec/#syntax_11","text":"(Enumeration Identifier [Identifier])","title":"Syntax"},{"location":"astspec/#java-example_2","text":"public enum Fuzzy { YES, NO, MAYBE } (Enumeration Fuzzy [ YES , NO , MAYBE ])","title":"Java Example"},{"location":"astspec/#interface","text":"Object oriented programming global interface or contract declaration, composed by a name, superinterfaces and a body.","title":"Interface"},{"location":"astspec/#syntax_12","text":"(Interface Identifier [Identifier] Expression)","title":"Syntax"},{"location":"astspec/#java-example_3","text":"public interface Foo extends Bar, Baz { void foo(); } (Interface Foo [ Bar , Baz ] (TypeSignature foo [] void ))","title":"Java Example"},{"location":"astspec/#rule","text":"Logic programming declaration of rule fact, composed by the rule name, rule arguments, and rule body","title":"Rule"},{"location":"astspec/#syntax_13","text":"(Rule Identifier [Pattern] [Expression])","title":"Syntax"},{"location":"astspec/#example_5","text":"baz(bar) :- foo(bar) (Rule baz [(LiteralPattern bar )] [(Exist foo [(LiteralPattern bar )])])","title":"Example"},{"location":"astspec/#fact","text":"Logic programming declaration of a fact , composed by the fact name and fact arguments","title":"Fact"},{"location":"astspec/#syntax_14","text":"(Fact Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_6","text":"foo(bar). (Fact foo [(LiteralPattern bar )])","title":"Example"},{"location":"astspec/#exist","text":"Logic programming existential cuantification / consult","title":"Exist"},{"location":"astspec/#syntax_15","text":"(Exist Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_7","text":"","title":"Example"},{"location":"astspec/#not","text":"Logic programming negation","title":"Not"},{"location":"astspec/#syntax_16","text":"(Not Expression)","title":"Syntax"},{"location":"astspec/#example_8","text":"","title":"Example"},{"location":"astspec/#findall","text":"Logic programming findall","title":"Findall"},{"location":"astspec/#syntax_17","text":"(Findall Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#example_9","text":"","title":"Example"},{"location":"astspec/#forall","text":"Logic programming universal cuantification","title":"Forall"},{"location":"astspec/#syntax_18","text":"(Forall Expression Expression)","title":"Syntax"},{"location":"astspec/#example_10","text":"","title":"Example"},{"location":"astspec/#reference","text":"Generic variable","title":"Reference"},{"location":"astspec/#syntax_19","text":"(Reference Identifier)","title":"Syntax"},{"location":"astspec/#example_11","text":"","title":"Example"},{"location":"astspec/#application","text":"Generic, non-curried application of a function or procedure, composed by the applied element itself, and the application arguments","title":"Application"},{"location":"astspec/#syntax_20","text":"(Application Expression [Expression])","title":"Syntax"},{"location":"astspec/#example_12","text":"","title":"Example"},{"location":"astspec/#send","text":"Object oriented programming message send, composed by the reciever, selector and arguments","title":"Send"},{"location":"astspec/#syntax_21","text":"(Send Expression Expression [Expression])","title":"Syntax"},{"location":"astspec/#ruby-example_3","text":"1 + 5 (Send (MuNumber 1) (Reference + ) [MuNumber 5])","title":"Ruby Example"},{"location":"astspec/#new","text":"Object oriented instantiation, composed by the class reference and instantiation arguments","title":"New"},{"location":"astspec/#syntax_22","text":"(New Identifier [Expression])","title":"Syntax"},{"location":"astspec/#example_13","text":"","title":"Example"},{"location":"astspec/#implement","text":"Object oriented instantiation, interface implementation","title":"Implement"},{"location":"astspec/#syntax_23","text":"(Implement Identifier)","title":"Syntax"},{"location":"astspec/#example_14","text":"","title":"Example"},{"location":"astspec/#include","text":"Object oriented instantiation, mixin inclusion","title":"Include"},{"location":"astspec/#syntax_24","text":"(Include Identifier)","title":"Syntax"},{"location":"astspec/#example_15","text":"","title":"Example"},{"location":"astspec/#if","text":"","title":"If"},{"location":"astspec/#syntax_25","text":"(If Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#lambda","text":"","title":"Lambda"},{"location":"astspec/#syntax_26","text":"(Lambda [Pattern] Expression)","title":"Syntax"},{"location":"astspec/#return","text":"","title":"Return"},{"location":"astspec/#syntax_27","text":"(Return Expression)","title":"Syntax"},{"location":"astspec/#while","text":"Imperative programming conditional repetition control structure, composed by a condition and a body","title":"While"},{"location":"astspec/#syntax_28","text":"(While Expression Expression)","title":"Syntax"},{"location":"astspec/#example_16","text":"","title":"Example"},{"location":"astspec/#repeat","text":"Imperative programming fixed repetition control structure, composed by a repetition count expression, and a body","title":"Repeat"},{"location":"astspec/#syntax_29","text":"(Repeat Expression Expression)","title":"Syntax"},{"location":"astspec/#example_17","text":"","title":"Example"},{"location":"astspec/#match","text":"","title":"Match"},{"location":"astspec/#syntax_30","text":"(Match Expression [Equation])","title":"Syntax"},{"location":"astspec/#switch","text":"","title":"Switch"},{"location":"astspec/#syntax_31","text":"(Switch Expression [(Expression, Expression)])","title":"Syntax"},{"location":"astspec/#try","text":"Generic try expression, composed by a body, a list of exception-handling patterns and statments, and a finally expression","title":"Try"},{"location":"astspec/#syntax_32","text":"(Try Expression [(Pattern, Expression)] Expression)","title":"Syntax"},{"location":"astspec/#example_18","text":"","title":"Example"},{"location":"astspec/#raise","text":"Generic raise expression, like a throw or raise statament, composed by the raised expression","title":"Raise"},{"location":"astspec/#syntax_33","text":"(Raise Expression)","title":"Syntax"},{"location":"astspec/#example_19","text":"","title":"Example"},{"location":"astspec/#print","text":"Generic print expression","title":"Print"},{"location":"astspec/#syntax_34","text":"(Print Expression)","title":"Syntax"},{"location":"astspec/#ruby-example_4","text":"puts Hello World (Print (MuString Hello World ))","title":"Ruby Example"},{"location":"astspec/#for","text":"For s generalices the concept of comprehensions an indexed repetition. With a For you can build: ForComprehension , when the for expression is a yield. Scala's for comprehensions, Erlang's and Haskell's list comprehensions, and Haskell's do-syntaxt map to it. ForEach , when the for expression is not a yield. Java's for: , or some scenarios of scala's for map to it.","title":"For"},{"location":"astspec/#syntax_35","text":"(For [Statment] Expression)","title":"Syntax"},{"location":"astspec/#haskell-example","text":"m = [ f x | x - [1, 2, 3, 4] ] (Variable m (For [(Generator (VariablePattern x ) (MuList [(MuNumber 1), (MuNumber 2), (MuNumber 3), (MuNumber 4)]))] (Yield (Application (Reference f ) [(Reference x )]))))","title":"Haskell Example"},{"location":"astspec/#java-example_4","text":"for (Integer i : ints) { System.out.println(i); } (For [(Generator (VariablePattern i ) (Reference ints ))] (Print (Reference i )))","title":"Java Example"},{"location":"astspec/#forloop","text":"ForLoop represents the imperative programming c-style for loop:","title":"ForLoop"},{"location":"astspec/#syntax_36","text":"(ForLoop Expression Expression Expression Expression)","title":"Syntax"},{"location":"astspec/#example_20","text":"for (var i = 0; i 10; i++) { console.log(i); } (ForLoop (Variable i (MuNumber 0.0)) (Application (Reference ) [Reference i ,MuNumber 10.0]) (Assignment i (Application (Reference + ) [Reference i ,MuNumber 1.0])) (Send (Reference console ) (Reference log ) [Reference i ]))","title":"Example"},{"location":"astspec/#sequence","text":"Generic sequence of statements","title":"Sequence"},{"location":"astspec/#syntax_37","text":"(Sequence [Expression])","title":"Syntax"},{"location":"astspec/#example_21","text":"","title":"Example"},{"location":"astspec/#other","text":"","title":"Other"},{"location":"astspec/#syntax_38","text":"(Other)","title":"Syntax"},{"location":"astspec/#equal-and-notequal","text":"","title":"Equal and NotEqual"},{"location":"astspec/#syntax_39","text":"(Equal) (NotEqual)","title":"Syntax"},{"location":"astspec/#self","text":"Object oriented self-reference, like C-like this and Smalltalk-derived self","title":"Self"},{"location":"astspec/#syntax_40","text":"(Self)","title":"Syntax"},{"location":"astspec/#none","text":"Used as a placeholder for empty bodies.","title":"None"},{"location":"astspec/#syntax_41","text":"(None)","title":"Syntax"},{"location":"astspec/#munil","text":"Generic nothing value literal - nil , null , () or unit .","title":"MuNil"},{"location":"astspec/#syntax_42","text":"(MuNil)","title":"Syntax"},{"location":"astspec/#muobject","text":"Object oriented unnamed object literal","title":"MuObject"},{"location":"astspec/#syntax_43","text":"(MuObject Expression)","title":"Syntax"},{"location":"astspec/#javascript-example","text":"{} {foo: 1} {foo: 1, bar: 2} (MuObject MuNil) (MuObject (Attribute foo (MuNumber 1))) (MuObject (Sequence [ (Attribute foo (MuNumber 1)), (Attribute bar (MuNumber 2))]))","title":"JavaScript Example"},{"location":"astspec/#munumber-mubool-mustring-musymbol-and-muchar","text":"Generic number, boolean, string, symbol (atoms) and char literals","title":"MuNumber, MuBool, MuString, MuSymbol and MuChar"},{"location":"astspec/#syntax_44","text":"(MuNumber Double) (MuBool Bool) (MuString String) (MuSymbol String) (MuChar Char)","title":"Syntax"},{"location":"astspec/#ruby-example_5","text":"1 true hello :hello (Sequence [ (MuNumber 1), (MuBool True), (MuString hello ), (MuSymbol hello )])","title":"Ruby Example"},{"location":"astspec/#mutuple-and-mulist","text":"They represent tuples - generic non-uniform fixed-size collection of elements - and lists - generic uniform variable-size collection of elements. Lists typically map to arrays, lists or sequence-like structures.","title":"MuTuple and MuList"},{"location":"astspec/#syntax_45","text":"(MuTuple [Expression]) (MuList [Expression])","title":"Syntax"},{"location":"astspec/#testgroup-test-and-assert","text":"Generic test framework expressions used to represent unit tests. TestGroup represents a test grouping expression such as describe , context , etc Test represents a test expression such as it , etc Assert represents a test's assertion, such as assert.equals(...) , etc. It receives a boolean that represents whether the assertion is negated or not.","title":"TestGroup, Test and Assert"},{"location":"astspec/#syntax_46","text":"(TestGroup Expression Expression) (Test Expression Expression) (Assert Bool Assertion)","title":"Syntax"},{"location":"astspec/#javascript-example_1","text":"describe( succ , function() { it( succ of 3 is 4 , function() { assert.equals(succ(3), 4) }) }) TestGroup (MuString succ ) (Test (MuString succ of 3 is 4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0))))","title":"Javascript Example"},{"location":"astspec/#python-example","text":"class TestGroup(unittest.TestCase): def test_succ_of_3_is_4(): self.assertEqual(succ(3), 4) TestGroup (MuString TestGroup ) (Test (MuString test_succ_of_3_is_4 ) (Assert False (Equality (Application (Reference succ ) [MuNumber 3.0]) (MuNumber 4.0))))","title":"Python Example"},{"location":"astspec/#assertion","text":"Assertions used within tests to dynamically ascertain the code's validity. An assertion can be one of: * Truth : Assert the truthfulness of a given expression. * Equality : Assert the equality of two given expressions. * Failure : Assert a given expression fails with a given error.","title":"Assertion"},{"location":"astspec/#syntax_47","text":"(Truth Expression) (Equality Expression Expression) (Failure Expression Expression)","title":"Syntax"},{"location":"astspec/#javascript-examples","text":"assert(true) Assert False (Truth (MuBool True)) assert.equals(3, 3) Assert False (Equality (MuNumber 3) (MuNumber 3)) assert.throws(function() { throw('error!') }, 'error!') Assert False (Failure (Lambda [] (Raise (MuString error! ))) (MuString error! ))","title":"Javascript Examples"},{"location":"astspec/#patterns","text":"Patterns are the second most important element of Mulang AST. They represent things that don't hold a value, but are instead used to match values, like patterns in imperative case or switch statements, functional pattern matching in match or case expressions, or exception matching in try-catch or begin-rescue -like statements in object oriented languages.","title":"Patterns"},{"location":"astspec/#variablepattern","text":"Variable pattern represent a variable match. It corresponds to normal formal parameters in precedural languages, and to simple pattern matching against a free identifier.","title":"VariablePattern"},{"location":"astspec/#syntax_48","text":"(VariablePattern String)","title":"Syntax"},{"location":"astspec/#javascript-example_2","text":"function foo(x, y) { } (Function foo [(Equation [(VariablePattern x ), (VariablePattern y )] (UnguardedBody MuNil))])","title":"JavaScript Example"},{"location":"astspec/#literalpattern","text":"Literal constant pattern","title":"LiteralPattern"},{"location":"astspec/#syntax_49","text":"(LiteralPattern String)","title":"Syntax"},{"location":"astspec/#example_22","text":"","title":"Example"},{"location":"astspec/#infixapplicationpattern","text":"Infix application pattern like 4:X","title":"InfixApplicationPattern"},{"location":"astspec/#syntax_50","text":"(InfixApplicationPattern Pattern String Pattern)","title":"Syntax"},{"location":"astspec/#caveats_1","text":"InfixApplicationPattern exposes the underying syntax and will be deprecated.","title":"Caveats"},{"location":"astspec/#applicationpattern","text":"prefix application pattern like f _","title":"ApplicationPattern"},{"location":"astspec/#syntax_51","text":"(ApplicationPattern String [Pattern])","title":"Syntax"},{"location":"astspec/#example_23","text":"","title":"Example"},{"location":"astspec/#tuplepattern","text":"tuple pattern like (3, _)","title":"TuplePattern"},{"location":"astspec/#syntax_52","text":"(TuplePattern [Pattern])","title":"Syntax"},{"location":"astspec/#example_24","text":"","title":"Example"},{"location":"astspec/#listpattern","text":"list pattern like [x, y, _]","title":"ListPattern"},{"location":"astspec/#syntax_53","text":"(ListPattern [Pattern])","title":"Syntax"},{"location":"astspec/#example_25","text":"","title":"Example"},{"location":"astspec/#functorpattern","text":"Prolog-like functor pattern, like f(X, 6) .","title":"FunctorPattern"},{"location":"astspec/#syntax_54","text":"(FunctorPattern Identifier [Pattern])","title":"Syntax"},{"location":"astspec/#example_26","text":"","title":"Example"},{"location":"astspec/#aspattern","text":"","title":"AsPattern"},{"location":"astspec/#syntax_55","text":"(AsPattern Identifier Pattern)","title":"Syntax"},{"location":"astspec/#example_27","text":"","title":"Example"},{"location":"astspec/#typepattern","text":"A type pattern, like in exception handling constructs in most object-oriented languages","title":"TypePattern"},{"location":"astspec/#syntax_56","text":"(TypePattern Identifier)","title":"Syntax"},{"location":"astspec/#example_28","text":"","title":"Example"},{"location":"astspec/#wildcardpattern","text":"Wildcard pattern, typically _ in functional an logic programming languages.","title":"WildcardPattern"},{"location":"astspec/#syntax_57","text":"(WildcardPattern)","title":"Syntax"},{"location":"astspec/#unionpattern","text":"","title":"UnionPattern"},{"location":"astspec/#syntax_58","text":"(UnionPattern [Pattern])","title":"Syntax"},{"location":"astspec/#otherpattern","text":"Other unrecognized pattern","title":"OtherPattern"},{"location":"astspec/#syntax_59","text":"(OtherPattern)","title":"Syntax"},{"location":"astspec/#types","text":"When processing statically-typed languages, all type-information - regardless we are typing a function, a variable or a class - is represented with the Type ADT, can be one of: SimpleType : composed by a type identifier and zero or type more constraints ParameterizedType : composed by input type parmaters, an output type, and type constratins ConstrainedType : composed by just type constraints. OtherType : an unrecognized type Type s can be introduced in the Mulang AST using the following elements:","title":"Types"},{"location":"astspec/#typealias","text":"A TypeAlias represents a synonym for a type, like the type declaration in Haskell and Scala or C's typedef . It is a typical statically typed functional programming feature.","title":"TypeAlias"},{"location":"astspec/#syntax_60","text":"(TypeAlias Identifier Identifier)","title":"Syntax"},{"location":"astspec/#haskell-example_1","text":"type Point = (Int, Int) (TypeAlias Point (Int, Int) )","title":"Haskell Example"},{"location":"astspec/#typesignature","text":"A TypeSignature represents an explicit type annotation for a computation, variable or module, as you can find in Java or Haskell.","title":"TypeSignature"},{"location":"astspec/#syntax_61","text":"(TypeSignature Identifier Type)","title":"Syntax"},{"location":"astspec/#haskell-examples","text":"Simple types: name :: String (TypeSignature name (SimpleType String [])) Simple types and constraints: f :: Num a = a ```` ```haskell (TypeSignature f (SimpleType a [ Num a ])) Parameterized types: elem :: (Eq a, Foldable t) = a - t a - Bool ```` ```haskell (TypeSignature elem (ParameterizedType [ a , t a ] Bool [ Eq a , Foldable t ]))","title":"Haskell Examples"},{"location":"astspec/#java-examples_1","text":"In Java, as in most typed C-like languages, type signature and variable declarations are bound. This means that, for example, a local variable declaration will produce both a TypeSignature and a Variable expression. Variable and attribute types: String name; (TypeSignature name (SimpleType String [])) Method types: String f() { return null; } (TypeSignature f (ParameterizedType [] String [])) Method types with type parameters: A A f() { return null; } (TypeSignature f (ParameterizedType [] A [ A ])) Method types with type parameters and constraints: A super B void f(A a) {} (TypeSignature f (ParameterizedType [ A ] void [ A super B ])) Class or interfaces types: class A B extends C, D extends C { } (TypeSignature A (ConstrainedType [ B extends C , D extends C ]))","title":"Java Examples"},{"location":"astspec/#typecast","text":"A TypeCast represent explictly giving a type to an expression which may have static or dynamic impact on the program. It is aimed to represent type-casts in c-like languages and inline type signatures in functional languages.","title":"TypeCast"},{"location":"astspec/#syntax_62","text":"(TypeCast Expression Type)","title":"Syntax"},{"location":"astspec/#haskell-examples_1","text":"Simple types: ... = 4 :: Num a = a (TypeCast (MuNumber 4) (SimpleType a [ Num a ]))","title":"Haskell Examples"},{"location":"astspec/#java-examples_2","text":"Variable and attribute types: (Integer) 4; (TypeCast (MuNumber 4) (SimpleType Integer [])) (Option Integer ) something; (TypeCast (Reference something ) (SimpleType Option Integer []))","title":"Java Examples"},{"location":"astspec/#caveats_2","text":"The type constraints refer to type-constrained parametrizations that the cast introduces, and not any other kind of constraints the cast uses. That is whay the following Java code: (Num A ) something; produces: (TypeCast (Reference something ) (SimpleType Num A [])) instead of: (TypeCast (Reference something ) (SimpleType Num [ A ]))","title":"Caveats"},{"location":"build/","text":"Building mulang from source Setup To generate mulang executable, you have to build the project using stack : Install stack: wget -qO- https://get.haskellstack.org/ | sh Go to the mulang project directory and setup it: stack setup Build the project: stack build Installing and creating an executable $ stack install $ mulang That will generate a mulang executable in the folder ~/.local/bin . Running tests $ stack test --fast Watching changes $ stack test --fast --file-watch Loading mulang in the REPL stack ghci Ruby wrapper This module can also be deployed a ruby gem. mulang works with Ruby 2.3.1 cd gem rake wrapper:wrap bundle install bundle exec rspec See gem/README for more details. JavaScript library mulang can also be compiled to JavaScript library using ghcjs and ghcjslib , which allows you to use it from node or the browser. :warning: you will need node = 7 installed on your system. If you have nvm , before starting run the following: sh $ nvm use $(cat ghcjslib/.nvmrc) Run ghcjslib/swap.sh for swapping to GHCJS compiler Run ghcjslib/build.sh for building the ghcjslib release. It will be placed on ghcjslib/build/mulang.js Run ghcjslib/test.sh for running both mocha and hspec tests. Load it: in the browser: google-chrome ghcjslib/index.html in node : run node , and then, within the interpreter, run: let mulang = require('./ghcjslib/build/mulang.js'); Try it: mulang.analyse(...pass here a spec as described in the README....) Run ghcjslib/swap.sh again for swapping back to ghc Tagging and releasing ./tag.sh Updating docs These site is build using mkdocs = 0.17 . You can install it using pip : $ pip install mkdocs From the project root folder, running mkdocs serve will serve the files in a local server, mkdocs build will build the static site to a foldes called site , and deploys to the gh-pages branch are done by running mkdocs gh-deploy directly.","title":"Build"},{"location":"build/#building-mulang-from-source","text":"","title":"Building mulang from source"},{"location":"build/#setup","text":"To generate mulang executable, you have to build the project using stack : Install stack: wget -qO- https://get.haskellstack.org/ | sh Go to the mulang project directory and setup it: stack setup Build the project: stack build","title":"Setup"},{"location":"build/#installing-and-creating-an-executable","text":"$ stack install $ mulang That will generate a mulang executable in the folder ~/.local/bin .","title":"Installing and creating an executable"},{"location":"build/#running-tests","text":"$ stack test --fast","title":"Running tests"},{"location":"build/#watching-changes","text":"$ stack test --fast --file-watch","title":"Watching changes"},{"location":"build/#loading-mulang-in-the-repl","text":"stack ghci","title":"Loading mulang in the REPL"},{"location":"build/#ruby-wrapper","text":"This module can also be deployed a ruby gem. mulang works with Ruby 2.3.1 cd gem rake wrapper:wrap bundle install bundle exec rspec See gem/README for more details.","title":"Ruby wrapper"},{"location":"build/#javascript-library","text":"mulang can also be compiled to JavaScript library using ghcjs and ghcjslib , which allows you to use it from node or the browser. :warning: you will need node = 7 installed on your system. If you have nvm , before starting run the following: sh $ nvm use $(cat ghcjslib/.nvmrc) Run ghcjslib/swap.sh for swapping to GHCJS compiler Run ghcjslib/build.sh for building the ghcjslib release. It will be placed on ghcjslib/build/mulang.js Run ghcjslib/test.sh for running both mocha and hspec tests. Load it: in the browser: google-chrome ghcjslib/index.html in node : run node , and then, within the interpreter, run: let mulang = require('./ghcjslib/build/mulang.js'); Try it: mulang.analyse(...pass here a spec as described in the README....) Run ghcjslib/swap.sh again for swapping back to ghc","title":"JavaScript library"},{"location":"build/#tagging-and-releasing","text":"./tag.sh","title":"Tagging and releasing"},{"location":"build/#updating-docs","text":"These site is build using mkdocs = 0.17 . You can install it using pip : $ pip install mkdocs From the project root folder, running mkdocs serve will serve the files in a local server, mkdocs build will build the static site to a foldes called site , and deploys to the gh-pages branch are done by running mkdocs gh-deploy directly.","title":"Updating docs"},{"location":"try/","text":"div.bs-sidebar.hidden-print.affix.well{ display: none; } .col-md-3{display: none;} .col-md-9{width: 100%} #spec { font-family:Consolas,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New, monospace; height: 600px } Analyse","title":"Try it!"},{"location":"userguide/","text":"Combinators Crash course Better than explaining what Mulang is, let's see what can do it for you. Inspections Let's suppose we have the following JS code... var aPlace = buenosAires; var aBird = {position: aPlace, weight: 20}; ...and we want to recognize some code patterns on it. We will first load the expression into Mulang: $ ghci :m Language.Mulang.All let e = js var aPlace = buenosAires; var aBird = {position: aPlace, weight: 20}; Now the magic begins. We want to know if the code expression uses - that is, contains any reference to - a given identifier . Such identifier could be a variable, function, or anything that has a name: uses (named buenosAires ) e True -- because of the reference in `...aPlace = buenosAires...` uses (named rosario ) e False -- no reference to the identifier `rosario` is found on the code uses (named \"buenosAires\") is our first inspection : a function that takes a Mulang AST and answers a boolan question about it. That seems easy, but just in case you are wondering: no, Mulang doesn't perform a string.contains or something like that :stuck_out_tongue: : uses (named buenos ) e False -- no reference to the identifier `buenos` is found on the code Inspection Combinators So let's ask something more interesting - does aPlace use the identifier buenosAires ? scoped (uses (named buenosAires )) aPlace e True -- again, because of the the reference in `...aPlace = buenosAires...` scoped (uses (named buenosAires )) aBird e False -- because `...aBird = {position: aPlace, weight: 20}...` does not reference `buenosAires` directly... Here we have used the our first inspection combinator , a function that takes an inspection - uses (named \"buenosAires\") - and returns a new one that is more powerful. In this case, scoped is capable of restricting the analysis to the given context - the aPlace identifier. Let's tray again: does \"aPlace\" it use rosario ? scoped (uses (named rosario )) aPlace e False What about the object aBird ? Does it use aPlace or rosario ? scoped (uses (named aPlace )) aBird e True scoped (uses (named rosario )) aBird e False Oh, wait! Let go back to scoped (uses (named \"buenosAires\")) \"aBird\" e . We know, it is true that it does not use exactly that variable, aPlace does use buenosAires ! Wouldn't it be sweet to be transitive? transitive (uses (named buenosAires )) aBird e True Here we can see another inspections combinator : transitive , which inspects the given context and all the contexts that are refered from it. Contexts can be nested, too: for example, if you want to know whether aBird.position uses aPlace - ignoring that weight attribute: scopedList (uses (named aPlace )) [ aBird , position ] e True scopedList (uses (named aPlace )) [ aBird , weight ] e False Nice, we know. But not very awesome, it only can tell you if you are using a identifier , right? Eeer. Good news, it can tell you much much much more things. See the supported inspections list . Identifier predicates In previous examples, we have always combined the uses inspection with the named function, but what does named mean? Many inspections support an identifier predicate , that is, a matcher for identifier. It can be one of the following: anyone : true for all identifiers except : true for any identifier different to the given one like : true for any identifier that contains the given one named : true for only the given identifier andAlso : identifier predicates combiner. True when both predicates are True anyOf : identifier predicates combiner. True when any of the predicates are True For example, does the former piece of code declare any attribute? declaresAttribute anyone e True Does it declare an attribute like eight ? declaresAttribute (like eight ) e True And does aBird use any if within its definition? scoped usesIf aBird e False Detections Let's suppose we want to knoe whether something returns null in the following code: let e = js var bar = {baz: function(){ return g }, foo: function(){ return null }} We could manually check if it is the foo method in bar or the baz method in bar : scopedList returnsNil [ bar , foo ] e True scopedList returnsNil [ bar , baz ] e False But instead of asking one by one, we could use detect : detect returnsNil e [ bar , foo ] -- This means that there are null returns within `bar` and also within `foo`. detect converts an inspection into a detection : a function that tells which identifier match a given criteria. Supported inspections The power of Mulang is grounded on more than 70 different kind of inspections: Inspection Paradigm Meaning assigns any the given variable or attribute assigned? calls any is the given method, function or procedure called? declares any is the given element declared? declaresAttribute object oriented is a given attribute declared? declaresClass object oriented is a given class declared? declaresComputation any that is, does the given computation - method, predicate, function, etc - exist? declaresComputationWithArity any that is, does the given computation have the exact given arity? declaresEntryPoint any is there a program entry point, like a main procedure? declaresEnumeration imperative is a given enumeration declared? declaresFact logic is a given logic fact declared? declaresFunction functional/imperative is a given function declared? declaresInterface object oriented is a given interface declared? declaresMethod object oriented is a given method declared? declaresObject object oriented is a given named object declared? declaresPredicate logic is a given rule o fact declared? declaresProcedure imperative is a given procedure declared? declaresRecursively any is a given computation declared using recusion? declaresRule logic is a given logic rule declared? declaresSuperclass object oriented is a given class declared as superclass? declaresTypeAlias any is a given type synonym declared? declaresTypeSignature any is a given computation type signature declared? declaresVariable any is a given local o global variable declared? discardsExceptions any are exceptions discarded within an empty catch block? doesConsolePrint any is there any console-print-statement like System.out.println , puts or console.log ? doesNullTest object oriented is there a test agains a null value, like if x == nil then puts 'is nil' doesTypeTest hasAssignmentReturn hasCodeDuplication any has the given code simple literal code duplication? hasEmptyIfBranches any has the given code an empty if branch? hasLongParameterList any does a given method/function/predicate take too many parameters? hasMisspelledIdentifiers any an identifier is not a domain language dictionary's word and not part of its jargon hasRedundantBooleanComparison hasRedundantGuards hasRedundantIf any can a combination of if s, assignment s and return s be replaced by a boolean expression? hasRedundantLambda hasRedundantLocalVariableReturn hasRedundantParameter hasRedundantReduction logic is a is-operator used to unify individuals that don't require a reduction, like X is 4 hasTooManyMethods object oriented does a given class/object/interface have too many methods? hasTooShortIdentifiers any whether an identifier is too short and not part of domain language's jargon hasUnreachableCode any is there unreachable code? hasWrongCaseIdentifiers any whether an identifier does not match the domain language's case style implements object oriented is the given interface implemented? includes object oriented is a given mixins included? inherits object oriented is a given class declared as superclass? - alias of declaresSuperclass instantiates object oriented is the given class instantiated? isLongCode any has the code long sequences of statements? overridesEqualsOrHashButNotBoth object oriented does a given class override equals but not hash? or hash but not equals? raises any is the given exception type raised? rescues any is the given exception type rescued? returnsNill typesAs any is the given type used to type a variable? typesParameterAs any is a parameter typed as a given type? typesReturnAs any is the given type used to type a return? uses any is there any reference to the given element? usesAnonymousVariable usesComposition usesConditional usesCut logic is the logic ! consult used? usesDyamicPolymorphism object oriented are there two or more methods definitions for some sent selector? usesDynamicMethodOverload object oriented is there a class that defined two methods with different arity but with the same name? usesExceptionHandling any is any exception handlded? usesExceptions any is any exception raised? usesFail logic is the logic fail consult used? usesFindall logic is the logic findall consult used? usesFor any is any kind of comprehension or indexed repetition used? usesForall logic is the logic forall consult used? usesForComprehension functional is the functional for/do/list comprehension used? usesForEach procedural is the procedural indexed repetition used? usesForLoop procedural is a c-style for loop used? usesGuards usesIf any is an if control structure used? usesInheritance object oriented is any superclass explicitly declared? usesLambda usesLoop procedural are any of: repeat / for loop / foreach / while used? usesMixins object oriented is any mixins explicitly included? usesNot usesObjectComposition object oriented is there a class that declares an attributes and sends a message to it? usesPatternMatching usesRepeat usesStaticMethodOverload object oriented is there a class that defined two method signatures but with the same name? usesStaticPolymorphism object oriented is there an interface with at least a method signature that is implemented by two or more classes and used in the code? usesSwitch usesTemplateMethod object oriented is there a class that sends a message whose corresonding method is not declared? usesType any is the given typed used in a signature? usesUnificationOperator logic is the logic unification operator = used? usesWhile imperative is a while control structure used? usesYield functional is an expression yielded within a comprehension? Supported languages Mulang is an universal tool which can work with many different programming languages. it natively supports: Haskell Java JavaScript (ES5) Python Prolog In addition, through external tools, it offers support for the following languages: Ruby, using mulang-ruby PHP, using mulang-php Gobstones, using gs-weblang-cli So in order to use it with a particular language, you have to: either add explicit support in this repo, or translate your language into one of the natively supported ones, or translate your language to the Mulang JSON AST Command Line Tool You can also use Mulang from the Command Line, without having to interact with Haskell code. This tool allows to perform most common analysis out of the box by using a JSON spec. It supports four different kinds of analysis: Expectation analysis : you can pass inspections that will be tested against the provied program. Expectations answer questions like: does the function X call the function Y? or does the program use if's? . Smell analysis : instead of asking explcit questions to the program, the smells analysis implicitly runs specific inspections - that denote bad code - in orden to know if any of them is matched. Intermediate Language analysis : you can ask the tool to generate the Mulang AST for a given source code. Signature analysis : report the signatures of the computations present in source code. The expectations DSL In order to pass expectations to the Command Line Tool, you must use a simple DSL that builds the inspections for you. Kind DSL Sample Haskell Combinators Sample Basic * UsesIf usesIf Negated * Not:UsesWhile (negative usesWhile) Predicated * DeclaresClass:Foo (declaresClass (named \"Foo\")) * DeclaresClass:=Foo (declaresClass (named \"Foo\")) * DeclaresClass:~Foo (declaresClass (like \"Foo\")) * DeclaresClass:^Foo (declaresClass (except \"Foo\")) * DeclaresClass:[Foo\\|Bar] (declaresClass (anyOf [\"Foo\", \"Bar\"])) * DeclaresClass:* (declaresClass anyone) * DeclaresClass (declaresClass anyone) Transitive foo UsesLambda (transitive usesLambda \"foo\") Scoped Intransitive:foo UsesIf (scoped usesIf \"foo\") Scoped List foo.bar UsesIf (scopedList usesIf [\"foo\", \"bar\"]) Examples Let's see some usage samples: With intransitive expectations $ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { expectations : [ { binding : :Intransitive:x , inspection : Uses:* } ], smellsSet : { tag : NoSmells } } } ' | json_pp { expectationResults : [ { expectation : { binding : :Intransitive:x , inspection : Uses:* }, result : false } ], smells : [], tag : AnalysisCompleted , signatures : [] } With unscoped expectations $ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { smellsSet : { tag : NoSmells }, expectations : [ { binding : * , inspection : Declares:x } ] } } ' | json_pp { tag : AnalysisCompleted , smells : [], expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ], signatures : [] } With signature analysis $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return x + y; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { expectationResults : [], smells : [], signatures : [ -- foo x y ], tag : AnalysisCompleted } With broken input $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y { return x + y; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } }' | json_pp { tag : AnalysisFailed , reason : Sample code parsing error } With AST as input $ mulang ' { sample : { tag : MulangSample , ast : { tag : Sequence , contents : [ { tag : Variable , contents : [ x , { tag : MuNumber , contents : 1 } ] }, { tag : Variable , contents : [ y , { tag : MuNumber , contents : 2 } ] } ] } }, spec : { smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle }, expectations : [] } } ' | json_pp { expectationResults : [], smells : [], tag : AnalysisCompleted , signatures : [ -- x , -- y ] } With Smell Analysis, by inclusion $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : NoSmells , include : [ ReturnsNil , DoesNullTest ] }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [], signatures : [ -- foo x y ], smells : [ { binding : foo , inspection : ReturnsNil } ] } With Smell Analysis, by exclusion $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : AllSmells , exclude : [ ReturnsNil ] }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { smells : [], signatures : [ -- foo x y ], tag : AnalysisCompleted , expectationResults : [] } With expressiveness smells Expressivnes smells are like other smells - they can be included or excluded using the smellsSet settings. However, their behaviour is also controlled by the domainLanguage setting, which you can configure: $ mulang ' { sample : { tag : CodeSample , language : Prolog , content : son(Parent, Son):-parentOf(Son, Parent).parentOf(bart, homer). }, spec : { expectations : [], smellsSet : { tag : AllSmells }, domainLanguage : { caseStyle : SnakeCase , minimumIdentifierSize : 4, jargon : [ id ] } } }' | json_pp { tag : AnalysisCompleted , signatures : [], smells : [ { inspection : HasTooShortIdentifiers , binding : son }, { binding : parentOf , inspection : HasWrongCaseIdentifiers } ], expectationResults : [] } Also, if you want to use HasMisspelledIdentifiers smell, you need to specify a dictionary - with must be ordered, downcased and with unique words only: $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : AllSmells }, domainLanguage : { dictionaryFilePath : /usr/share/dict/words } } }' | json_pp { tag : AnalysisCompleted , expectationResults : [], signatures : [], smells : [ { inspection : ReturnsNil , binding : foo }, { inspection : HasMisspelledIdentifiers , binding : foo } ] } With Intermediate Language Generation $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, includeIntermediateLanguage : true } } ' | json_pp { expectationResults : [], smells : [], tag : AnalysisCompleted , signatures : [], intermediateLanguage : { tag : Function , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x }, { tag : VariablePattern , contents : y } ], { tag : UnguardedBody , contents : { contents : { tag : MuNil }, tag : Return } } ] ] ] } }","title":"User Guide"},{"location":"userguide/#combinators-crash-course","text":"Better than explaining what Mulang is, let's see what can do it for you.","title":"Combinators Crash course"},{"location":"userguide/#inspections","text":"Let's suppose we have the following JS code... var aPlace = buenosAires; var aBird = {position: aPlace, weight: 20}; ...and we want to recognize some code patterns on it. We will first load the expression into Mulang: $ ghci :m Language.Mulang.All let e = js var aPlace = buenosAires; var aBird = {position: aPlace, weight: 20}; Now the magic begins. We want to know if the code expression uses - that is, contains any reference to - a given identifier . Such identifier could be a variable, function, or anything that has a name: uses (named buenosAires ) e True -- because of the reference in `...aPlace = buenosAires...` uses (named rosario ) e False -- no reference to the identifier `rosario` is found on the code uses (named \"buenosAires\") is our first inspection : a function that takes a Mulang AST and answers a boolan question about it. That seems easy, but just in case you are wondering: no, Mulang doesn't perform a string.contains or something like that :stuck_out_tongue: : uses (named buenos ) e False -- no reference to the identifier `buenos` is found on the code","title":"Inspections"},{"location":"userguide/#inspection-combinators","text":"So let's ask something more interesting - does aPlace use the identifier buenosAires ? scoped (uses (named buenosAires )) aPlace e True -- again, because of the the reference in `...aPlace = buenosAires...` scoped (uses (named buenosAires )) aBird e False -- because `...aBird = {position: aPlace, weight: 20}...` does not reference `buenosAires` directly... Here we have used the our first inspection combinator , a function that takes an inspection - uses (named \"buenosAires\") - and returns a new one that is more powerful. In this case, scoped is capable of restricting the analysis to the given context - the aPlace identifier. Let's tray again: does \"aPlace\" it use rosario ? scoped (uses (named rosario )) aPlace e False What about the object aBird ? Does it use aPlace or rosario ? scoped (uses (named aPlace )) aBird e True scoped (uses (named rosario )) aBird e False Oh, wait! Let go back to scoped (uses (named \"buenosAires\")) \"aBird\" e . We know, it is true that it does not use exactly that variable, aPlace does use buenosAires ! Wouldn't it be sweet to be transitive? transitive (uses (named buenosAires )) aBird e True Here we can see another inspections combinator : transitive , which inspects the given context and all the contexts that are refered from it. Contexts can be nested, too: for example, if you want to know whether aBird.position uses aPlace - ignoring that weight attribute: scopedList (uses (named aPlace )) [ aBird , position ] e True scopedList (uses (named aPlace )) [ aBird , weight ] e False Nice, we know. But not very awesome, it only can tell you if you are using a identifier , right? Eeer. Good news, it can tell you much much much more things. See the supported inspections list .","title":"Inspection Combinators"},{"location":"userguide/#identifier-predicates","text":"In previous examples, we have always combined the uses inspection with the named function, but what does named mean? Many inspections support an identifier predicate , that is, a matcher for identifier. It can be one of the following: anyone : true for all identifiers except : true for any identifier different to the given one like : true for any identifier that contains the given one named : true for only the given identifier andAlso : identifier predicates combiner. True when both predicates are True anyOf : identifier predicates combiner. True when any of the predicates are True For example, does the former piece of code declare any attribute? declaresAttribute anyone e True Does it declare an attribute like eight ? declaresAttribute (like eight ) e True And does aBird use any if within its definition? scoped usesIf aBird e False","title":"Identifier predicates"},{"location":"userguide/#detections","text":"Let's suppose we want to knoe whether something returns null in the following code: let e = js var bar = {baz: function(){ return g }, foo: function(){ return null }} We could manually check if it is the foo method in bar or the baz method in bar : scopedList returnsNil [ bar , foo ] e True scopedList returnsNil [ bar , baz ] e False But instead of asking one by one, we could use detect : detect returnsNil e [ bar , foo ] -- This means that there are null returns within `bar` and also within `foo`. detect converts an inspection into a detection : a function that tells which identifier match a given criteria.","title":"Detections"},{"location":"userguide/#supported-inspections","text":"The power of Mulang is grounded on more than 70 different kind of inspections: Inspection Paradigm Meaning assigns any the given variable or attribute assigned? calls any is the given method, function or procedure called? declares any is the given element declared? declaresAttribute object oriented is a given attribute declared? declaresClass object oriented is a given class declared? declaresComputation any that is, does the given computation - method, predicate, function, etc - exist? declaresComputationWithArity any that is, does the given computation have the exact given arity? declaresEntryPoint any is there a program entry point, like a main procedure? declaresEnumeration imperative is a given enumeration declared? declaresFact logic is a given logic fact declared? declaresFunction functional/imperative is a given function declared? declaresInterface object oriented is a given interface declared? declaresMethod object oriented is a given method declared? declaresObject object oriented is a given named object declared? declaresPredicate logic is a given rule o fact declared? declaresProcedure imperative is a given procedure declared? declaresRecursively any is a given computation declared using recusion? declaresRule logic is a given logic rule declared? declaresSuperclass object oriented is a given class declared as superclass? declaresTypeAlias any is a given type synonym declared? declaresTypeSignature any is a given computation type signature declared? declaresVariable any is a given local o global variable declared? discardsExceptions any are exceptions discarded within an empty catch block? doesConsolePrint any is there any console-print-statement like System.out.println , puts or console.log ? doesNullTest object oriented is there a test agains a null value, like if x == nil then puts 'is nil' doesTypeTest hasAssignmentReturn hasCodeDuplication any has the given code simple literal code duplication? hasEmptyIfBranches any has the given code an empty if branch? hasLongParameterList any does a given method/function/predicate take too many parameters? hasMisspelledIdentifiers any an identifier is not a domain language dictionary's word and not part of its jargon hasRedundantBooleanComparison hasRedundantGuards hasRedundantIf any can a combination of if s, assignment s and return s be replaced by a boolean expression? hasRedundantLambda hasRedundantLocalVariableReturn hasRedundantParameter hasRedundantReduction logic is a is-operator used to unify individuals that don't require a reduction, like X is 4 hasTooManyMethods object oriented does a given class/object/interface have too many methods? hasTooShortIdentifiers any whether an identifier is too short and not part of domain language's jargon hasUnreachableCode any is there unreachable code? hasWrongCaseIdentifiers any whether an identifier does not match the domain language's case style implements object oriented is the given interface implemented? includes object oriented is a given mixins included? inherits object oriented is a given class declared as superclass? - alias of declaresSuperclass instantiates object oriented is the given class instantiated? isLongCode any has the code long sequences of statements? overridesEqualsOrHashButNotBoth object oriented does a given class override equals but not hash? or hash but not equals? raises any is the given exception type raised? rescues any is the given exception type rescued? returnsNill typesAs any is the given type used to type a variable? typesParameterAs any is a parameter typed as a given type? typesReturnAs any is the given type used to type a return? uses any is there any reference to the given element? usesAnonymousVariable usesComposition usesConditional usesCut logic is the logic ! consult used? usesDyamicPolymorphism object oriented are there two or more methods definitions for some sent selector? usesDynamicMethodOverload object oriented is there a class that defined two methods with different arity but with the same name? usesExceptionHandling any is any exception handlded? usesExceptions any is any exception raised? usesFail logic is the logic fail consult used? usesFindall logic is the logic findall consult used? usesFor any is any kind of comprehension or indexed repetition used? usesForall logic is the logic forall consult used? usesForComprehension functional is the functional for/do/list comprehension used? usesForEach procedural is the procedural indexed repetition used? usesForLoop procedural is a c-style for loop used? usesGuards usesIf any is an if control structure used? usesInheritance object oriented is any superclass explicitly declared? usesLambda usesLoop procedural are any of: repeat / for loop / foreach / while used? usesMixins object oriented is any mixins explicitly included? usesNot usesObjectComposition object oriented is there a class that declares an attributes and sends a message to it? usesPatternMatching usesRepeat usesStaticMethodOverload object oriented is there a class that defined two method signatures but with the same name? usesStaticPolymorphism object oriented is there an interface with at least a method signature that is implemented by two or more classes and used in the code? usesSwitch usesTemplateMethod object oriented is there a class that sends a message whose corresonding method is not declared? usesType any is the given typed used in a signature? usesUnificationOperator logic is the logic unification operator = used? usesWhile imperative is a while control structure used? usesYield functional is an expression yielded within a comprehension?","title":"Supported inspections"},{"location":"userguide/#supported-languages","text":"Mulang is an universal tool which can work with many different programming languages. it natively supports: Haskell Java JavaScript (ES5) Python Prolog In addition, through external tools, it offers support for the following languages: Ruby, using mulang-ruby PHP, using mulang-php Gobstones, using gs-weblang-cli So in order to use it with a particular language, you have to: either add explicit support in this repo, or translate your language into one of the natively supported ones, or translate your language to the Mulang JSON AST","title":"Supported languages"},{"location":"userguide/#command-line-tool","text":"You can also use Mulang from the Command Line, without having to interact with Haskell code. This tool allows to perform most common analysis out of the box by using a JSON spec. It supports four different kinds of analysis: Expectation analysis : you can pass inspections that will be tested against the provied program. Expectations answer questions like: does the function X call the function Y? or does the program use if's? . Smell analysis : instead of asking explcit questions to the program, the smells analysis implicitly runs specific inspections - that denote bad code - in orden to know if any of them is matched. Intermediate Language analysis : you can ask the tool to generate the Mulang AST for a given source code. Signature analysis : report the signatures of the computations present in source code.","title":"Command Line Tool"},{"location":"userguide/#the-expectations-dsl","text":"In order to pass expectations to the Command Line Tool, you must use a simple DSL that builds the inspections for you. Kind DSL Sample Haskell Combinators Sample Basic * UsesIf usesIf Negated * Not:UsesWhile (negative usesWhile) Predicated * DeclaresClass:Foo (declaresClass (named \"Foo\")) * DeclaresClass:=Foo (declaresClass (named \"Foo\")) * DeclaresClass:~Foo (declaresClass (like \"Foo\")) * DeclaresClass:^Foo (declaresClass (except \"Foo\")) * DeclaresClass:[Foo\\|Bar] (declaresClass (anyOf [\"Foo\", \"Bar\"])) * DeclaresClass:* (declaresClass anyone) * DeclaresClass (declaresClass anyone) Transitive foo UsesLambda (transitive usesLambda \"foo\") Scoped Intransitive:foo UsesIf (scoped usesIf \"foo\") Scoped List foo.bar UsesIf (scopedList usesIf [\"foo\", \"bar\"])","title":"The expectations DSL"},{"location":"userguide/#examples","text":"Let's see some usage samples:","title":"Examples"},{"location":"userguide/#with-intransitive-expectations","text":"$ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { expectations : [ { binding : :Intransitive:x , inspection : Uses:* } ], smellsSet : { tag : NoSmells } } } ' | json_pp { expectationResults : [ { expectation : { binding : :Intransitive:x , inspection : Uses:* }, result : false } ], smells : [], tag : AnalysisCompleted , signatures : [] }","title":"With intransitive expectations"},{"location":"userguide/#with-unscoped-expectations","text":"$ mulang ' { sample : { tag : CodeSample , language : Haskell , content : x = 1 }, spec : { smellsSet : { tag : NoSmells }, expectations : [ { binding : * , inspection : Declares:x } ] } } ' | json_pp { tag : AnalysisCompleted , smells : [], expectationResults : [ { result : true, expectation : { binding : * , inspection : Declares:x } } ], signatures : [] }","title":"With unscoped expectations"},{"location":"userguide/#with-signature-analysis","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return x + y; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { expectationResults : [], smells : [], signatures : [ -- foo x y ], tag : AnalysisCompleted }","title":"With signature analysis"},{"location":"userguide/#with-broken-input","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y { return x + y; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } }' | json_pp { tag : AnalysisFailed , reason : Sample code parsing error }","title":"With broken input"},{"location":"userguide/#with-ast-as-input","text":"$ mulang ' { sample : { tag : MulangSample , ast : { tag : Sequence , contents : [ { tag : Variable , contents : [ x , { tag : MuNumber , contents : 1 } ] }, { tag : Variable , contents : [ y , { tag : MuNumber , contents : 2 } ] } ] } }, spec : { smellsSet : { tag : NoSmells }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle }, expectations : [] } } ' | json_pp { expectationResults : [], smells : [], tag : AnalysisCompleted , signatures : [ -- x , -- y ] }","title":"With AST as input"},{"location":"userguide/#with-smell-analysis-by-inclusion","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : NoSmells , include : [ ReturnsNil , DoesNullTest ] }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { tag : AnalysisCompleted , expectationResults : [], signatures : [ -- foo x y ], smells : [ { binding : foo , inspection : ReturnsNil } ] }","title":"With Smell Analysis, by inclusion"},{"location":"userguide/#with-smell-analysis-by-exclusion","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : AllSmells , exclude : [ ReturnsNil ] }, signatureAnalysisType : { tag : StyledSignatures , style : HaskellStyle } } } ' | json_pp { smells : [], signatures : [ -- foo x y ], tag : AnalysisCompleted , expectationResults : [] }","title":"With Smell Analysis, by exclusion"},{"location":"userguide/#with-expressiveness-smells","text":"Expressivnes smells are like other smells - they can be included or excluded using the smellsSet settings. However, their behaviour is also controlled by the domainLanguage setting, which you can configure: $ mulang ' { sample : { tag : CodeSample , language : Prolog , content : son(Parent, Son):-parentOf(Son, Parent).parentOf(bart, homer). }, spec : { expectations : [], smellsSet : { tag : AllSmells }, domainLanguage : { caseStyle : SnakeCase , minimumIdentifierSize : 4, jargon : [ id ] } } }' | json_pp { tag : AnalysisCompleted , signatures : [], smells : [ { inspection : HasTooShortIdentifiers , binding : son }, { binding : parentOf , inspection : HasWrongCaseIdentifiers } ], expectationResults : [] } Also, if you want to use HasMisspelledIdentifiers smell, you need to specify a dictionary - with must be ordered, downcased and with unique words only: $ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : AllSmells }, domainLanguage : { dictionaryFilePath : /usr/share/dict/words } } }' | json_pp { tag : AnalysisCompleted , expectationResults : [], signatures : [], smells : [ { inspection : ReturnsNil , binding : foo }, { inspection : HasMisspelledIdentifiers , binding : foo } ] }","title":"With expressiveness smells"},{"location":"userguide/#with-intermediate-language-generation","text":"$ mulang ' { sample : { tag : CodeSample , language : JavaScript , content : function foo(x, y) { return null; } }, spec : { expectations : [], smellsSet : { tag : NoSmells }, includeIntermediateLanguage : true } } ' | json_pp { expectationResults : [], smells : [], tag : AnalysisCompleted , signatures : [], intermediateLanguage : { tag : Function , contents : [ foo , [ [ [ { tag : VariablePattern , contents : x }, { tag : VariablePattern , contents : y } ], { tag : UnguardedBody , contents : { contents : { tag : MuNil }, tag : Return } } ] ] ] } }","title":"With Intermediate Language Generation"}]}